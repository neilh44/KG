<!DOCTYPE html>
<html>
<head>
    <title>BTC Orbital View - Aryabhata's Celestial Mechanics</title>
    <style>
        body { margin: 0; background: #0a0a0a; color: white; font-family: Arial; overflow: hidden; }
        #info { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; }
        #canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸŒŸ BTC Orbital Mechanics</h3>
        <div id="data">Loading celestial data...</div>
    </div>
    <canvas id="canvas"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('data');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let btcData = [];
        let orbitalCenter = 0;
        let orbitalRadius = 0;
        let currentPhase = 0;
        let currentPrice = 0;
        let momentum = 0;
        let escapeVelocity = 0;
        
        // Fetch BTC data from Binance
        async function fetchBTCData() {
            try {
                const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=100');
                const klines = await response.json();
                btcData = klines.map(k => parseFloat(k[4])); // Close prices
                
                // Calculate orbital parameters
                calculateOrbitalParameters();
                calculateMomentum();
                updateInfo();
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }
        
        function calculateOrbitalParameters() {
            if (btcData.length < 3) return;
            
            // Find orbital center (geometric center)
            const minPrice = Math.min(...btcData);
            const maxPrice = Math.max(...btcData);
            const priceRange = maxPrice - minPrice;
            
            let minVariance = Infinity;
            let bestCenter = (minPrice + maxPrice) / 2;
            
            for (let i = 0; i <= 40; i++) {
                const testCenter = minPrice + (priceRange * i / 40);
                const variance = btcData.reduce((sum, price) => sum + Math.pow(price - testCenter, 2), 0);
                
                if (variance < minVariance) {
                    minVariance = variance;
                    bestCenter = testCenter;
                }
            }
            
            orbitalCenter = bestCenter;
            
            // Calculate orbital radius (RMS)
            const distances = btcData.map(price => Math.abs(price - orbitalCenter));
            orbitalRadius = Math.sqrt(distances.reduce((sum, d) => sum + d * d, 0) / distances.length);
            
            // Calculate current phase
            currentPrice = btcData[btcData.length - 1];
            const relativePosition = currentPrice - orbitalCenter;
            currentPhase = Math.atan2(relativePosition, orbitalRadius);
            if (currentPhase < 0) currentPhase += 2 * Math.PI;
        }
        
        function calculateMomentum() {
            if (btcData.length < 10) return;
            
            // Calculate price velocity (change rate)
            const recent = btcData.slice(-10);
            let totalVelocity = 0;
            for (let i = 1; i < recent.length; i++) {
                totalVelocity += recent[i] - recent[i-1];
            }
            const velocity = totalVelocity / (recent.length - 1);
            
            // Momentum = velocity * mass (using distance from center as mass)
            const mass = Math.abs(currentPrice - orbitalCenter) + 1;
            momentum = Math.abs(velocity * mass);
            
            // Escape velocity = sqrt(2 * orbital_radius) - simplified orbital mechanics
            escapeVelocity = Math.sqrt(2 * orbitalRadius);
        }
        
        function updateInfo() {
            const momentumStatus = momentum >= escapeVelocity ? "ðŸš€ BREAKOUT" : "ðŸ”„ ORBITAL";
            const requiredEscape = escapeVelocity - momentum;
            
            info.innerHTML = `
                <strong>Current Price:</strong> ${currentPrice.toFixed(2)}<br>
                <strong>Orbital Center:</strong> ${orbitalCenter.toFixed(2)}<br>
                <strong>Orbital Radius:</strong> ${orbitalRadius.toFixed(2)}<br>
                <strong>Phase:</strong> ${(currentPhase * 180 / Math.PI).toFixed(1)}Â°<br>
                <strong>Distance from Center:</strong> ${Math.abs(currentPrice - orbitalCenter).toFixed(2)}<br>
                <strong>Momentum:</strong> ${momentum.toFixed(2)} ${momentumStatus}<br>
                <strong>Escape Velocity:</strong> ${escapeVelocity.toFixed(2)}<br>
                <strong>Required to Escape:</strong> ${requiredEscape > 0 ? requiredEscape.toFixed(2) : 'ACHIEVED'}
            `;
        }
        
        function drawOrbitalView() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) * 0.3 / orbitalRadius;
            
            // Draw orbital center (sun/gravitational center)
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(`Center: $${orbitalCenter.toFixed(0)}`, centerX + 15, centerY);
            
            // Draw orbital circles (multiple orbits)
            for (let r = orbitalRadius * 0.5; r <= orbitalRadius * 2; r += orbitalRadius * 0.25) {
                ctx.strokeStyle = `rgba(100, 100, 100, ${0.3 - (r / orbitalRadius - 1) * 0.1})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r * scale, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw escape velocity orbit (2x radius)
            ctx.strokeStyle = momentum >= escapeVelocity ? '#ff4444' : '#ff8888';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, orbitalRadius * 2 * scale, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw main orbital path
            ctx.strokeStyle = '#4a90e2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, orbitalRadius * scale, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw price history as orbital trail
            ctx.strokeStyle = '#32cd32';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 1; i < btcData.length; i++) {
                const price1 = btcData[i - 1];
                const price2 = btcData[i];
                
                const rel1 = price1 - orbitalCenter;
                const rel2 = price2 - orbitalCenter;
                
                const phase1 = Math.atan2(rel1, Math.abs(rel1)) + Math.PI/2;
                const phase2 = Math.atan2(rel2, Math.abs(rel2)) + Math.PI/2;
                
                const radius1 = Math.abs(rel1) * scale;
                const radius2 = Math.abs(rel2) * scale;
                
                const x1 = centerX + radius1 * Math.cos(phase1);
                const y1 = centerY + radius1 * Math.sin(phase1);
                const x2 = centerX + radius2 * Math.cos(phase2);
                const y2 = centerY + radius2 * Math.sin(phase2);
                
                if (i === 1) {
                    ctx.moveTo(x1, y1);
                }
                ctx.lineTo(x2, y2);
            }
            ctx.stroke();
            
            // Draw current price position (planet/celestial body)
            const currentDistance = Math.abs(currentPrice - orbitalCenter) * scale;
            const adjustedPhase = Math.atan2(currentPrice - orbitalCenter, currentDistance / scale) + Math.PI/2;
            
            const currentX = centerX + currentDistance * Math.cos(adjustedPhase);
            const currentY = centerY + currentDistance * Math.sin(adjustedPhase);
            
            // Current price (bright planet with corona effect)
            const glowColor = momentum >= escapeVelocity ? '#ff0066' : '#ff6666';
            const gradient = ctx.createRadialGradient(currentX, currentY, 0, currentX, currentY, 15);
            gradient.addColorStop(0, glowColor);
            gradient.addColorStop(0.3, '#ff4444');
            gradient.addColorStop(0.7, '#ff2222');
            gradient.addColorStop(1, 'rgba(255, 34, 34, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(currentX, currentY, 15, 0, 2 * Math.PI);
            ctx.fill();
            
            // Core planet
            ctx.fillStyle = momentum >= escapeVelocity ? '#ffff00' : '#ffff00';
            ctx.beginPath();
            ctx.arc(currentX, currentY, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            // Pulsing ring around current price
            const time = Date.now() * 0.01;
            const pulseRadius = 8 + Math.sin(time) * 2;
            const pulseColor = momentum >= escapeVelocity ? '#ff0066' : '#ffff00';
            ctx.strokeStyle = `rgba(255, ${momentum >= escapeVelocity ? '6, 102' : '255, 0'}, ${0.5 + Math.sin(time) * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(currentX, currentY, pulseRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Price label
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`$${currentPrice.toFixed(0)}`, currentX + 10, currentY - 10);
            
            // Draw phase indicator
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            // Phase arc
            ctx.strokeStyle = 'rgba(255, 212, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, 0, adjustedPhase);
            ctx.stroke();
            
            // Draw quadrant labels (like astronomical directions)
            const labelRadius = orbitalRadius * scale + 30;
            ctx.fillStyle = '#888';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            ctx.fillText('BULL ZONE', centerX, centerY - labelRadius - 10);
            ctx.fillText('BEAR ZONE', centerX, centerY + labelRadius + 20);
            ctx.textAlign = 'left';
            ctx.fillText('RISING', centerX + labelRadius + 10, centerY);
            ctx.fillText('FALLING', centerX - labelRadius - 40, centerY);
            
            // Escape velocity label
            ctx.fillStyle = momentum >= escapeVelocity ? '#ff4444' : '#ff8888';
            ctx.textAlign = 'center';
            ctx.font = '10px Arial';
            ctx.fillText('ESCAPE ORBIT', centerX, centerY - orbitalRadius * 2 * scale - 15);
            
            // Draw grid/constellation lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 6) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + orbitalRadius * scale * Math.cos(angle), 
                          centerY + orbitalRadius * scale * Math.sin(angle));
                ctx.stroke();
            }
        }
        
        function animate() {
            if (btcData.length > 0) {
                drawOrbitalView();
            }
            requestAnimationFrame(animate);
        }
        
        // Auto-refresh data every 30 seconds
        setInterval(fetchBTCData, 30000);
        
        // Initial load
        fetchBTCData().then(() => {
            animate();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>